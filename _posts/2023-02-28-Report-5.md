---
title: "5 :  Loop's in Rust"
layout: post
date: 2023-02-28
---
# Loops in Rust

Similar to other programming languages Rust had while and for loops adding to that, Rust also had the **loop** pre defined function which starts the loops immeditely.

# Rust loop
A **loop** expression that prints “Hello” until it is broken by a condition:


        let mut count = 0;
        loop {
            count += 1;
            println!("Hello");
            if count == 5 {
                break;
            }
        }

# While loop
A while expression that prints numbers from 1 to 5, it is created with the keyword **while**.

      let mut counter = 1;
      while counter < 6 {
          println!("{}", counter);
          counter += 1;
      }

# For Loop
A for expression that iterates over a range and prints 
“FizzBuzz” for multiples of 15, “Fizz” for multiples of 3 and “Buzz” for multiples of 5:

    for n in 1..101 {
                if n % 15 == 0 {
                    println!("FizzBuzz");
                } else if n % 3 == 0 {
                    println!("Fizz");
                } else if n % 5 == 0 {
                    println!("Buzz");
                } else {
                    println!("{}", n);
                }
            }
# Rust Ownership
Ownership is a set of rules that govern how a Rust program manages memory1. It enables Rust to make memory safety guarantees without needing a garbage collector2. Ownership is based on three principles.

1. Each value in Rust has an owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.

Example:-
if we have a variable x that owns a value 10, we can assign it to another variable y, but then x will no longer own the value. The ownership is transferred to y. When y goes out of scope, the value 10 will be freed from memory.

        let x = 10; // x owns 10
        let y = x; // y owns 10, x does not
        // do something with y
        // y goes out of scope, 10 is dropped

# Creating Class in Rust
Creating a class with MyClass name using struct with one field x of type i32. The impl block defines three methods for the struct: new, which constructs a new instance of the struct; print_x, which prints the value of the field x; and double_x, which doubles the value of the field x.

In the main function, we create an instance of MyClass using the new method and assign it to a mutable variable. Then we call the two methods on this instance using dot notation.

    Code:-
            struct MyClass {
                            x: i32,
                        }

                        impl MyClass {
                            fn new(x: i32) -> MyClass {
                                MyClass { x }
                            }

                            fn print_x(&self) {
                                println!("x is: {}", self.x);
                            }

                            fn double_x(&mut self) {
                                self.x *= 2;
                            }
                        }

                        fn main() {
                            let mut my_instance = MyClass::new(10);
                            my_instance.print_x();
                            my_instance.double_x();
                            my_instance.print_x();
                        }

            When you run this code, it will print:

                                                    x is: 10
                                                    x is: 20